{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"mkdocstrings-crystal # Crystal language doc generator for MkDocs , via mkdocstrings . Installation # $ pip install mkdocstrings-crystal Continue with quickstart . Or use the migration guide for a low-effort transition from crystal doc . Introduction # Crystal has its own easy-to-use generator of API documentation sites , but it's very rigid, as it doesn't attempt to do anything other than API documentation, so these sites end up being very isolated and prevent the author from presenting some kind of story about using their library. Instead, this plugin is all about that story . It's very inspiring to look at Python's documentation for subprocess , and hard to imagine a world in which this document is just an alphabetic dump of the functions in it. So (matching the idea behind mkdocstrings but for Crystal), this allows you to just write textual documentation in Markdown and, in the middle of it, mention any identifier of a Crystal type, method etc., and have its API documentation (signature and doc comment) printed out right there. Usage # With MkDocs , add/merge this base config as your mkdocs.yml : site_name : My Project theme : name : material plugins : - search - mkdocstrings : default_handler : crystal watch : [ src ] markdown_extensions : - pymdownx.highlight - deduplicate-toc Then, in any docs/**/*.md file, you can mention a Crystal identifier alone on a line, after ::: : ::: MyClass ::: Other::Class#some_method ::: Foo::CONSTANT -- and in the output this will be replaced with generated API documentation for it, much like Crystal's own doc generator does. Learn more about this syntax: in mkdocstrings in general (Crystal specifics are below). The auto-replacement, of course, happens as part of a normal MkDocs build process: $ mkdocs build # generate from docs/ into site/ $ mkdocs serve # live preview Identifier linking syntax # The syntax for these \"callouts\" is almost exactly the same as in Crystal's own doc comments. As you may also know, if you mention an identifier in backticks within a doc comment (e.g. `SomeClass#some_method` ) , Crystal's doc generator will cross-link to it. The same also works seamlessly here, and you don't need to change anything (other than possible edge cases). But another powerful feature of this plugin is that you can cross-reference items like this anywhere on the site , not just in doc comments. But the syntax is [SomeClass#some_method][] instead. Or [with custom text][SomeClass#some_method] . Note, though, that currently this cross-reference syntax is quite rigid, and you need to specify the exact absolute identifier as mkdocstrings-crystal determines it. To find that out, you could click on the wanted item in the navigation and then copy the anchor part from the URL bar -- the part after (not including) # . Usage details # We have been talking about seamlessly inserting Crystal documentation, but where is it coming from? The implementation actually still uses crystal doc generator but through its JSON output . So the requirement is the same: the source code that the doc comments and signatures are coming from is assumed to be somewhere under the src/ directory. If that isn't appropriate, you can select the wanted entry files by passing them to crystal doc , as part of crystal_docs_flags (see \"Custom source directories\" in Showcase ). Continue to Configuration .","title":"Introduction"},{"location":"index.html#mkdocstrings-crystal","text":"Crystal language doc generator for MkDocs , via mkdocstrings .","title":"mkdocstrings-crystal"},{"location":"index.html#installation","text":"$ pip install mkdocstrings-crystal Continue with quickstart . Or use the migration guide for a low-effort transition from crystal doc .","title":"Installation"},{"location":"index.html#introduction","text":"Crystal has its own easy-to-use generator of API documentation sites , but it's very rigid, as it doesn't attempt to do anything other than API documentation, so these sites end up being very isolated and prevent the author from presenting some kind of story about using their library. Instead, this plugin is all about that story . It's very inspiring to look at Python's documentation for subprocess , and hard to imagine a world in which this document is just an alphabetic dump of the functions in it. So (matching the idea behind mkdocstrings but for Crystal), this allows you to just write textual documentation in Markdown and, in the middle of it, mention any identifier of a Crystal type, method etc., and have its API documentation (signature and doc comment) printed out right there.","title":"Introduction"},{"location":"index.html#usage","text":"With MkDocs , add/merge this base config as your mkdocs.yml : site_name : My Project theme : name : material plugins : - search - mkdocstrings : default_handler : crystal watch : [ src ] markdown_extensions : - pymdownx.highlight - deduplicate-toc Then, in any docs/**/*.md file, you can mention a Crystal identifier alone on a line, after ::: : ::: MyClass ::: Other::Class#some_method ::: Foo::CONSTANT -- and in the output this will be replaced with generated API documentation for it, much like Crystal's own doc generator does. Learn more about this syntax: in mkdocstrings in general (Crystal specifics are below). The auto-replacement, of course, happens as part of a normal MkDocs build process: $ mkdocs build # generate from docs/ into site/ $ mkdocs serve # live preview","title":"Usage"},{"location":"index.html#identifier-linking-syntax","text":"The syntax for these \"callouts\" is almost exactly the same as in Crystal's own doc comments. As you may also know, if you mention an identifier in backticks within a doc comment (e.g. `SomeClass#some_method` ) , Crystal's doc generator will cross-link to it. The same also works seamlessly here, and you don't need to change anything (other than possible edge cases). But another powerful feature of this plugin is that you can cross-reference items like this anywhere on the site , not just in doc comments. But the syntax is [SomeClass#some_method][] instead. Or [with custom text][SomeClass#some_method] . Note, though, that currently this cross-reference syntax is quite rigid, and you need to specify the exact absolute identifier as mkdocstrings-crystal determines it. To find that out, you could click on the wanted item in the navigation and then copy the anchor part from the URL bar -- the part after (not including) # .","title":"Identifier linking syntax"},{"location":"index.html#usage-details","text":"We have been talking about seamlessly inserting Crystal documentation, but where is it coming from? The implementation actually still uses crystal doc generator but through its JSON output . So the requirement is the same: the source code that the doc comments and signatures are coming from is assumed to be somewhere under the src/ directory. If that isn't appropriate, you can select the wanted entry files by passing them to crystal doc , as part of crystal_docs_flags (see \"Custom source directories\" in Showcase ). Continue to Configuration .","title":"Usage details"},{"location":"api.html","text":"mkdocstrings.handlers.crystal.collector.CrystalCollector # root : DocRoot property readonly # The top-level namespace, represented as a fake module. __init__ ( self , crystal_docs_flags : Sequence [ str ] = (), source_locations : Mapping [ str , str ] = ()) special # Create a \"collector\", reading docs from crystal doc in the current directory. Normally this should not be instantiated. When using mkdocstrings-crystal within MkDocs, a plugin can access the instance as config['plugins']['mkdocstrings'].get_handler('crystal').collector . See Extras . mkdocstrings.handlers.crystal.items.DocItem # A representation of a documentable item from Crystal language. abs_id : str property readonly # The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id. doc : str property readonly # The doc comment of this item. kind : str property readonly # One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant name : str property readonly # The name of this item, e.g. Foo or baz . parent : Optional [ mkdocstrings . handlers . crystal . items . DocItem ] # The item that is the parent namespace for this item. rel_id : str property readonly # The relative identifier of this item, e.g. Foo or baz(x,y) . lookup ( self , identifier : Union [ str , DocPath ]) -> DocItem # Find an item by its identifier, relative to this item or the root. Parameters: Name Type Description Default identifier Union[str, DocPath] The item to search for. required Returns: Type Description DocItem An object that's a subclass of DocItem. Exceptions: Type Description CollectionError When an item by that identifier couldn't be found. Subclasses of DocItem # DocType # A DocItem representing a Crystal type. abs_id property readonly # The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id. ancestors : Sequence [ DocPath ] property readonly # The modules and classes this type inherited. class_methods : DocMapping [ DocClassMethod ] property readonly # The class methods within this type. constants : DocMapping [ DocConstant ] property readonly # The constants (or enum members) within this type. constructors : DocMapping [ DocConstructor ] property readonly # The constructors within this type. extended_modules : Sequence [ DocPath ] property readonly # The modules that this type extended. full_name : str property readonly # The path of this item, e.g. Foo::Bar(T) or baz . included_modules : Sequence [ DocPath ] property readonly # The modules that this type included. including_types : Sequence [ DocPath ] property readonly # Known types that include this type. instance_methods : DocMapping [ DocInstanceMethod ] property readonly # The instance methods within this type. is_abstract : bool property readonly # Whether this type is abstract. kind : str property readonly # One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant locations : Sequence [ DocLocation ] property readonly # The code locations over which the definitions of this type span. macros : DocMapping [ DocMacro ] property readonly # The macros within this type. subclasses : Sequence [ DocPath ] property readonly # Known subclasses of this type. superclass : Optional [ DocPath ] property readonly # The possible superclass of this type. types : DocMapping [ DocType ] property readonly # The types nested in this type as a namespace. walk_types ( self ) -> Iterator [ DocType ] # Recusively iterate over all types under this type (excl. itself) in lexicographic order. Subclasses of DocType # DocModule # A DocType representing a Crystal module. DocClass # A DocType representing a Crystal class. DocStruct # A DocType representing a Crystal struct. DocEnum # A DocType representing a Crystal enum. DocAlias # A DocType representing a Crystal alias. aliased : crystal_html . TextWithLinks property readonly # A rich string containing the definition of what this is aliased to. constants property readonly # The constants (or enum members) within this type. DocAnnotation # A DocType representing a Crystal annotation. DocConstant # A DocItem representing a Crystal constant definition. abs_id property readonly # The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id. kind : str property readonly # One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant value : str property readonly # The value of the constant (the code as a string). DocMethod # A DocItem representing a Crystal method. abs_id property readonly # The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id. args_string : crystal_html . TextWithLinks property readonly # A rich string with the method's parameters. e.g. (foo : Bar) : Baz is_abstract : bool property readonly # Whether this method is abstract. location : Optional [ DocLocation ] property readonly # Code location of this method. Can be None if unknown. rel_id property readonly # The relative identifier of this item, e.g. Foo or baz(x,y) . short_name property readonly # Similar to rel_id , but also includes the separator first, e.g. #bar(x,y) or .baz() Subclasses of DocMethod # DocInstanceMethod # A DocMethod representing a Crystal instance method. kind : str property readonly # One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant DocClassMethod # A DocMethod representing a Crystal class method. kind : str property readonly # One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant DocConstructor # A DocInstanceMethod representing a Crystal macro. DocMacro # A DocMethod representing a Crystal macro. kind : str property readonly # One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant Utilities # mkdocstrings.handlers.crystal.items.DocMapping # Represents items contained within a type. A container of DocItem s. __bool__ ( self ) -> bool special # bool(mapping) to check whether it's non-empty. __contains__ ( self , key : str ) -> bool special # \"identifier\" in mapping to check whether the mapping contains an item by this identifier (see DocItem.rel_id ). __getitem__ ( self , key : str ) -> D special # mapping[\"identifier\"] to get the item by this identifier (see DocItem.rel_id ). Returns: Type Description D A DocItem Exceptions: Type Description KeyError if the item is missing. __iter__ ( self ) -> Iterator [ D ] special # Iterate over the items like a list. __len__ ( self ) -> int special # len(mapping) to get the number of items. mkdocstrings.handlers.crystal.items.DocLocation dataclass # A location in code where an item was found. filename : str dataclass-field # The absolute path to the file. line : int dataclass-field # The (1-based) line number in the file. url : Optional [ str ] dataclass-field # The derived URL of this location on a source code hosting site. mkdocstrings.handlers.crystal.items.DocPath # A path to a documentable Crystal item. abs_id : str property readonly # The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz . full_name : str property readonly # The path of this item, e.g. Foo::Bar(T) or baz . __str__ ( self ) -> str special # Convert to string -- same as full_name . lookup ( self ) -> DocItem # Look up this item in its originating doc structure. Exceptions: Type Description CollectionError When an item by this identifier couldn't be found. mkdocstrings.handlers.crystal.crystal_html.TextWithLinks # A string with embedded information about which parts of it are links to other items. Can be converted to an actual string with str(obj) -- or used directly, being a subclass of str . The link information is currently for internal use only.","title":"Introspection API"},{"location":"api.html#mkdocstrings.handlers.crystal.collector.CrystalCollector","text":"","title":"CrystalCollector"},{"location":"api.html#mkdocstrings.handlers.crystal.collector.CrystalCollector.root","text":"The top-level namespace, represented as a fake module.","title":"root"},{"location":"api.html#mkdocstrings.handlers.crystal.collector.CrystalCollector.__init__","text":"Create a \"collector\", reading docs from crystal doc in the current directory. Normally this should not be instantiated. When using mkdocstrings-crystal within MkDocs, a plugin can access the instance as config['plugins']['mkdocstrings'].get_handler('crystal').collector . See Extras .","title":"__init__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem","text":"A representation of a documentable item from Crystal language.","title":"DocItem"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.abs_id","text":"The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id.","title":"abs_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.doc","text":"The doc comment of this item.","title":"doc"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.kind","text":"One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant","title":"kind"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.name","text":"The name of this item, e.g. Foo or baz .","title":"name"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.parent","text":"The item that is the parent namespace for this item.","title":"parent"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.rel_id","text":"The relative identifier of this item, e.g. Foo or baz(x,y) .","title":"rel_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocItem.lookup","text":"Find an item by its identifier, relative to this item or the root. Parameters: Name Type Description Default identifier Union[str, DocPath] The item to search for. required Returns: Type Description DocItem An object that's a subclass of DocItem. Exceptions: Type Description CollectionError When an item by that identifier couldn't be found.","title":"lookup()"},{"location":"api.html#subclasses-of-docitem","text":"","title":"Subclasses of DocItem"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType","text":"A DocItem representing a Crystal type.","title":"DocType"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.abs_id","text":"The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id.","title":"abs_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.ancestors","text":"The modules and classes this type inherited.","title":"ancestors"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.class_methods","text":"The class methods within this type.","title":"class_methods"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.constants","text":"The constants (or enum members) within this type.","title":"constants"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.constructors","text":"The constructors within this type.","title":"constructors"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.extended_modules","text":"The modules that this type extended.","title":"extended_modules"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.full_name","text":"The path of this item, e.g. Foo::Bar(T) or baz .","title":"full_name"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.included_modules","text":"The modules that this type included.","title":"included_modules"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.including_types","text":"Known types that include this type.","title":"including_types"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.instance_methods","text":"The instance methods within this type.","title":"instance_methods"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.is_abstract","text":"Whether this type is abstract.","title":"is_abstract"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.kind","text":"One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant","title":"kind"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.locations","text":"The code locations over which the definitions of this type span.","title":"locations"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.macros","text":"The macros within this type.","title":"macros"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.subclasses","text":"Known subclasses of this type.","title":"subclasses"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.superclass","text":"The possible superclass of this type.","title":"superclass"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.types","text":"The types nested in this type as a namespace.","title":"types"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocType.walk_types","text":"Recusively iterate over all types under this type (excl. itself) in lexicographic order.","title":"walk_types()"},{"location":"api.html#subclasses-of-doctype","text":"","title":"Subclasses of DocType"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocModule","text":"A DocType representing a Crystal module.","title":"DocModule"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocClass","text":"A DocType representing a Crystal class.","title":"DocClass"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocStruct","text":"A DocType representing a Crystal struct.","title":"DocStruct"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocEnum","text":"A DocType representing a Crystal enum.","title":"DocEnum"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocAlias","text":"A DocType representing a Crystal alias.","title":"DocAlias"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocAlias.aliased","text":"A rich string containing the definition of what this is aliased to.","title":"aliased"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocAlias.constants","text":"The constants (or enum members) within this type.","title":"constants"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocAnnotation","text":"A DocType representing a Crystal annotation.","title":"DocAnnotation"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocConstant","text":"A DocItem representing a Crystal constant definition.","title":"DocConstant"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocConstant.abs_id","text":"The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id.","title":"abs_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocConstant.kind","text":"One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant","title":"kind"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocConstant.value","text":"The value of the constant (the code as a string).","title":"value"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod","text":"A DocItem representing a Crystal method.","title":"DocMethod"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod.abs_id","text":"The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz(x,y) . This is also the canonical identifier that will be used as its HTML id.","title":"abs_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod.args_string","text":"A rich string with the method's parameters. e.g. (foo : Bar) : Baz","title":"args_string"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod.is_abstract","text":"Whether this method is abstract.","title":"is_abstract"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod.location","text":"Code location of this method. Can be None if unknown.","title":"location"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod.rel_id","text":"The relative identifier of this item, e.g. Foo or baz(x,y) .","title":"rel_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMethod.short_name","text":"Similar to rel_id , but also includes the separator first, e.g. #bar(x,y) or .baz()","title":"short_name"},{"location":"api.html#subclasses-of-docmethod","text":"","title":"Subclasses of DocMethod"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocInstanceMethod","text":"A DocMethod representing a Crystal instance method.","title":"DocInstanceMethod"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocInstanceMethod.kind","text":"One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant","title":"kind"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocClassMethod","text":"A DocMethod representing a Crystal class method.","title":"DocClassMethod"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocClassMethod.kind","text":"One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant","title":"kind"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocConstructor","text":"A DocInstanceMethod representing a Crystal macro.","title":"DocConstructor"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMacro","text":"A DocMethod representing a Crystal macro.","title":"DocMacro"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMacro.kind","text":"One of: module, class, struct, enum, alias, annotation, instance_method, class_method, macro, constant","title":"kind"},{"location":"api.html#utilities","text":"","title":"Utilities"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMapping","text":"Represents items contained within a type. A container of DocItem s.","title":"DocMapping"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMapping.__bool__","text":"bool(mapping) to check whether it's non-empty.","title":"__bool__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMapping.__contains__","text":"\"identifier\" in mapping to check whether the mapping contains an item by this identifier (see DocItem.rel_id ).","title":"__contains__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMapping.__getitem__","text":"mapping[\"identifier\"] to get the item by this identifier (see DocItem.rel_id ). Returns: Type Description D A DocItem Exceptions: Type Description KeyError if the item is missing.","title":"__getitem__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMapping.__iter__","text":"Iterate over the items like a list.","title":"__iter__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocMapping.__len__","text":"len(mapping) to get the number of items.","title":"__len__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocLocation","text":"A location in code where an item was found.","title":"DocLocation"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocLocation.filename","text":"The absolute path to the file.","title":"filename"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocLocation.line","text":"The (1-based) line number in the file.","title":"line"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocLocation.url","text":"The derived URL of this location on a source code hosting site.","title":"url"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocPath","text":"A path to a documentable Crystal item.","title":"DocPath"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocPath.abs_id","text":"The absolute identifier of this item, sometimes known as \"path\", e.g. Foo::Bar or Foo::Bar#baz .","title":"abs_id"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocPath.full_name","text":"The path of this item, e.g. Foo::Bar(T) or baz .","title":"full_name"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocPath.__str__","text":"Convert to string -- same as full_name .","title":"__str__()"},{"location":"api.html#mkdocstrings.handlers.crystal.items.DocPath.lookup","text":"Look up this item in its originating doc structure. Exceptions: Type Description CollectionError When an item by this identifier couldn't be found.","title":"lookup()"},{"location":"api.html#mkdocstrings.handlers.crystal.crystal_html.TextWithLinks","text":"A string with embedded information about which parts of it are links to other items. Can be converted to an actual string with str(obj) -- or used directly, being a subclass of str . The link information is currently for internal use only.","title":"TextWithLinks"},{"location":"configuration.html","text":"Configuration # Handler options # (See also: mkdocstrings global options ) crystal_docs_flags: # A list of command line arguments to pass to crystal doc . Mainly used to choose the source directories. The above option is global-only, while the ones below can also apply per-identifier. selection: # nested_types: ( true / false ) Set to true to also recursively render all Foo::Sub::Types whenever rendering a given class Foo . file_filters: [list of strings] If a particular module spans over several files, you might want to choose to render only the sub-items (see nested_types ) that came from a particular file. These patterns are regular expressions (not anchored) applied to the file path. Negating the patterns is done by starting it with ! (which is then excluded from the following regex). This is very similar to what's done in mkdocstrings rendering: # show_source_links: ( true / false ) Set to false to skip adding \" View source \" links after every method etc. heading_level: ( 1 / 2 / 3 / 4 / 5 / 6 ) Each inserted identifier gets an HTML heading. The default heading is <h2> , and sub-headings in it are shifted accordingly (so if you write headings in doc comments, you're welcome to start with # <h1> ). You can change this heading level, either the default one or per-identifier. Examples # A global config (part of mkdocs.yml) plugins : - mkdocstrings : default_handler : crystal watch : [ src ] handlers : crystal : crystal_docs_flags : - src/bar.cr - lib/foo/src/foo.cr rendering : show_source_links : false A per-identifier config (a callout in a Markdown file) ::: SomeModule selection: nested_types: true file_filters: - 'src/foo/[^/]+\\.cr$' rendering: heading_level: 3","title":"Configuration"},{"location":"configuration.html#configuration","text":"","title":"Configuration"},{"location":"configuration.html#handler-options","text":"(See also: mkdocstrings global options )","title":"Handler options"},{"location":"configuration.html#crystal_docs_flags","text":"A list of command line arguments to pass to crystal doc . Mainly used to choose the source directories. The above option is global-only, while the ones below can also apply per-identifier.","title":"crystal_docs_flags:"},{"location":"configuration.html#selection","text":"nested_types: ( true / false ) Set to true to also recursively render all Foo::Sub::Types whenever rendering a given class Foo . file_filters: [list of strings] If a particular module spans over several files, you might want to choose to render only the sub-items (see nested_types ) that came from a particular file. These patterns are regular expressions (not anchored) applied to the file path. Negating the patterns is done by starting it with ! (which is then excluded from the following regex). This is very similar to what's done in mkdocstrings","title":"selection:"},{"location":"configuration.html#rendering","text":"show_source_links: ( true / false ) Set to false to skip adding \" View source \" links after every method etc. heading_level: ( 1 / 2 / 3 / 4 / 5 / 6 ) Each inserted identifier gets an HTML heading. The default heading is <h2> , and sub-headings in it are shifted accordingly (so if you write headings in doc comments, you're welcome to start with # <h1> ). You can change this heading level, either the default one or per-identifier.","title":"rendering:"},{"location":"configuration.html#examples","text":"A global config (part of mkdocs.yml) plugins : - mkdocstrings : default_handler : crystal watch : [ src ] handlers : crystal : crystal_docs_flags : - src/bar.cr - lib/foo/src/foo.cr rendering : show_source_links : false A per-identifier config (a callout in a Markdown file) ::: SomeModule selection: nested_types: true file_filters: - 'src/foo/[^/]+\\.cr$' rendering: heading_level: 3","title":"Examples"},{"location":"extras.html","text":"Extras # \"deduplicate-toc\" extension # For most usages it is recommended to enable the \"deduplicate-toc\" Markdown extension, which comes bundled with mkdocstrings-crystal . It de-duplicates consecutive items that have the same title in the table of contents. This is important because Crystal can have multiple overloads of a method but in the ToC only their names are shown. Support for MkDocs \"macros\" plugin # Without support, you have to access the doc root as {% set crystal = config [ 'plugins' ][ 'mkdocstrings' ] .get_handler ( 'crystal' ) .collector.root %} But instead you can use the convenience pluglet shipped with mkdocstrings-crystal to have such a crystal object available in every page without the above assignment. mkdocs.yml plugins : - macros : modules : - mkdocstrings.handlers.crystal.macros Then you can dynamically generate Markdown based on introspecting Crystal's type tree. For example, instead of writing this in Markdown: These are the built-in mogrifier implementations: * [ Foo ][ MyModule::Mogrifiers::Foo ] * [ Bar ][ MyModule::Mogrifiers::Bar ] * [ Baz ][ MyModule::Mogrifiers::Baz ] ... you can just write: These are the built-in mogrifier implementations: {% for typ in crystal.lookup ( 'MyModule::Mogrifiers' ) .types %} - [ {{ typ.name }} ][ {{ typ.abs_id }} ] {% endfor %} Browse the API exposed by the root DocType . Support for MkDocs \"gen-files\" plugin # There's no special support, these just work well together. The plugin exposes the MkDocs config, and from there you can get to the doc root: root = config [ 'plugins' ][ 'mkdocstrings' ] . get_handler ( 'crystal' ) . collector . root Browse the API exposed by the root DocType . From there, you can generate Markdown files based on introspecting Crystal's type tree. This usage is described in the guide .","title":"Extras"},{"location":"extras.html#extras","text":"","title":"Extras"},{"location":"extras.html#deduplicate-toc-extension","text":"For most usages it is recommended to enable the \"deduplicate-toc\" Markdown extension, which comes bundled with mkdocstrings-crystal . It de-duplicates consecutive items that have the same title in the table of contents. This is important because Crystal can have multiple overloads of a method but in the ToC only their names are shown.","title":"\"deduplicate-toc\" extension"},{"location":"extras.html#support-for-mkdocs-macros-plugin","text":"Without support, you have to access the doc root as {% set crystal = config [ 'plugins' ][ 'mkdocstrings' ] .get_handler ( 'crystal' ) .collector.root %} But instead you can use the convenience pluglet shipped with mkdocstrings-crystal to have such a crystal object available in every page without the above assignment. mkdocs.yml plugins : - macros : modules : - mkdocstrings.handlers.crystal.macros Then you can dynamically generate Markdown based on introspecting Crystal's type tree. For example, instead of writing this in Markdown: These are the built-in mogrifier implementations: * [ Foo ][ MyModule::Mogrifiers::Foo ] * [ Bar ][ MyModule::Mogrifiers::Bar ] * [ Baz ][ MyModule::Mogrifiers::Baz ] ... you can just write: These are the built-in mogrifier implementations: {% for typ in crystal.lookup ( 'MyModule::Mogrifiers' ) .types %} - [ {{ typ.name }} ][ {{ typ.abs_id }} ] {% endfor %} Browse the API exposed by the root DocType .","title":"Support for MkDocs \"macros\" plugin"},{"location":"extras.html#support-for-mkdocs-gen-files-plugin","text":"There's no special support, these just work well together. The plugin exposes the MkDocs config, and from there you can get to the doc root: root = config [ 'plugins' ][ 'mkdocstrings' ] . get_handler ( 'crystal' ) . collector . root Browse the API exposed by the root DocType . From there, you can generate Markdown files based on introspecting Crystal's type tree. This usage is described in the guide .","title":"Support for MkDocs \"gen-files\" plugin"},{"location":"showcase.html","text":"Here are some websites using this doc generator: crystal-chipmunk # Home page \uff5c Repository Manually curated docs page \uff5c Source Tourmaline # Home page \uff5c Repository Textual docs page with generated references \uff5c Source Generated API docs page \uff5c gen_doc_stubs.py Partly inferred nav Custom styling Athena Framework # Home page \uff5c Website repository Generated API docs page \uff5c gen_doc_stubs.py Partly inferred nav Custom source directories \uff5c Multi-repo setup CrSFML # Home page \uff5c Repository Generated API docs page \uff5c gen_doc_stubs.py You might find more on GitHub .","title":"Showcase"},{"location":"showcase.html#crystal-chipmunk","text":"Home page \uff5c Repository Manually curated docs page \uff5c Source","title":"crystal-chipmunk"},{"location":"showcase.html#tourmaline","text":"Home page \uff5c Repository Textual docs page with generated references \uff5c Source Generated API docs page \uff5c gen_doc_stubs.py Partly inferred nav Custom styling","title":"Tourmaline"},{"location":"showcase.html#athena-framework","text":"Home page \uff5c Website repository Generated API docs page \uff5c gen_doc_stubs.py Partly inferred nav Custom source directories \uff5c Multi-repo setup","title":"Athena Framework"},{"location":"showcase.html#crsfml","text":"Home page \uff5c Repository Generated API docs page \uff5c gen_doc_stubs.py You might find more on GitHub .","title":"CrSFML"},{"location":"styling.html","text":"Recommended styles # Adding this styling to your site is recommended, otherwise things may not look right. You can, of course, adapt and add more. docs/css/mkdocstrings.css /* Indent and distinguish sub-items */ div . doc-contents : not ( . first ) { padding-left : 15 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); } mkdocs.yml extra_css : - css/mkdocstrings.css This is in addition to the mandatory style that mkdocstrings-crystal already inserts (just for reference): /* Prevent all-caps names in headings */ h5 . doc-heading { text-transform : none !important ; } /* [View source] links don't have brackets by default */ a . doc-source-link :: before { content : \"[\" ; color : var ( --md-typeset-color ); } a . doc-source-link :: after { content : \"]\" ; color : var ( --md-typeset-color ); } Custom styles # The doc items have consistently applied CSS classes. As of now, there is no separate documentation of what exactly they are. You are recommended to just inspect in the browser whenever you don't like the look of something and see how to reach it in CSS according to the markup. The above example is some inspiration. Also check out Showcase for more.","title":"Styling"},{"location":"styling.html#recommended-styles","text":"Adding this styling to your site is recommended, otherwise things may not look right. You can, of course, adapt and add more. docs/css/mkdocstrings.css /* Indent and distinguish sub-items */ div . doc-contents : not ( . first ) { padding-left : 15 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); } mkdocs.yml extra_css : - css/mkdocstrings.css This is in addition to the mandatory style that mkdocstrings-crystal already inserts (just for reference): /* Prevent all-caps names in headings */ h5 . doc-heading { text-transform : none !important ; } /* [View source] links don't have brackets by default */ a . doc-source-link :: before { content : \"[\" ; color : var ( --md-typeset-color ); } a . doc-source-link :: after { content : \"]\" ; color : var ( --md-typeset-color ); }","title":"Recommended styles"},{"location":"styling.html#custom-styles","text":"The doc items have consistently applied CSS classes. As of now, there is no separate documentation of what exactly they are. You are recommended to just inspect in the browser whenever you don't like the look of something and see how to reach it in CSS according to the markup. The above example is some inspiration. Also check out Showcase for more.","title":"Custom styles"},{"location":"troubleshooting.html","text":"Troubleshooting # Types aren't linkified in method signatures or aliases # Please make sure you're using the latest Crystal version - 0.36.0 at least. The plugin needs the included improvements, otherwise it gracefully degrades. Even if you haven't managed to get that version of Crystal locally, you can just rely on CI auto-deployment and assume that the links will work, even though you won't see them locally. The navigation sections look scattered # Perhaps it's because you made a page Foo.md and separately Foo/Bar.md . MkDocs just doesn't see them as related in any way. See also . Nav items are separated depending on if they have sub-items # In a deeply nested nav, it is best to stick to naming every file as index.md and making it the only one per directory. Then all items get treated equally during sorting. Or you can just define the nav yourself explicitly. It takes too long to build the site # Yes, it's slow, especially for large codebases. The main thing, though, is that MkDocs was not optimized to handle sites with so so many pages. That is, until I optimized it , but that hasn't made it into a release yet. Expect about a 2x speedup then. Or install the preview now: $ pip install -U git+https://github.com/mkdocs/mkdocs.git@refs/pull/2272/head The generated documentation does not look good # Note that only mkdocs-material theme is supported. You can always customize the styles with CSS , but make sure you've applied the default recommended style! MkDocs warns me about links to unfound documentation files # See documentation of mkdocstrings Warning: could not find cross-reference target # See documentation of mkdocstrings","title":"Troubleshooting"},{"location":"troubleshooting.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting.html#types-arent-linkified-in-method-signatures-or-aliases","text":"Please make sure you're using the latest Crystal version - 0.36.0 at least. The plugin needs the included improvements, otherwise it gracefully degrades. Even if you haven't managed to get that version of Crystal locally, you can just rely on CI auto-deployment and assume that the links will work, even though you won't see them locally.","title":"Types aren't linkified in method signatures or aliases"},{"location":"troubleshooting.html#the-navigation-sections-look-scattered","text":"Perhaps it's because you made a page Foo.md and separately Foo/Bar.md . MkDocs just doesn't see them as related in any way. See also .","title":"The navigation sections look scattered"},{"location":"troubleshooting.html#nav-items-are-separated-depending-on-if-they-have-sub-items","text":"In a deeply nested nav, it is best to stick to naming every file as index.md and making it the only one per directory. Then all items get treated equally during sorting. Or you can just define the nav yourself explicitly.","title":"Nav items are separated depending on if they have sub-items"},{"location":"troubleshooting.html#it-takes-too-long-to-build-the-site","text":"Yes, it's slow, especially for large codebases. The main thing, though, is that MkDocs was not optimized to handle sites with so so many pages. That is, until I optimized it , but that hasn't made it into a release yet. Expect about a 2x speedup then. Or install the preview now: $ pip install -U git+https://github.com/mkdocs/mkdocs.git@refs/pull/2272/head","title":"It takes too long to build the site"},{"location":"troubleshooting.html#the-generated-documentation-does-not-look-good","text":"Note that only mkdocs-material theme is supported. You can always customize the styles with CSS , but make sure you've applied the default recommended style!","title":"The generated documentation does not look good"},{"location":"troubleshooting.html#mkdocs-warns-me-about-links-to-unfound-documentation-files","text":"See documentation of mkdocstrings","title":"MkDocs warns me about links to unfound documentation files"},{"location":"troubleshooting.html#warning-could-not-find-cross-reference-target","text":"See documentation of mkdocstrings","title":"Warning: could not find cross-reference target"},{"location":"quickstart/index.html","text":"Quick-start guide # This assumes you already have some project in Crystal, say, a file src/foo.cr . src/foo.cr module Foo # Description of *Bar* class Bar # Description of *f* def f ( x : Int32 ) end end # Description of *g* # # See also: `Bar#f` def g ( bar : Bar ) end end Hosting on GitHub is also assumed, though that's easy to adapt. We'll be working from the project's root directory (the one that contains src ). View the final file layout Dependencies # The dependencies that we'll be using can be installed like this: $ pip install mkdocs-material mkdocstrings-crystal This assumes you have Python installed, with pip available. Tip You might want to install these in a virtualenv (i.e. localized just to this project). And check out how to manage Python dependencies long-term. Base config # Let's configure MkDocs with mkdocstrings-crystal . Add/merge this config as your mkdocs.yml : mkdocs.yml site_name : My Project site_url : https://username.github.io/my-project/ repo_url : https://github.com/username/my-project edit_uri : blob/master/docs/ theme : name : material icon : repo : fontawesome/brands/github extra_css : - css/mkdocstrings.css plugins : - search - mkdocstrings : default_handler : crystal watch : [ src ] markdown_extensions : - pymdownx.highlight - pymdownx.magiclink - pymdownx.saneheaders - pymdownx.superfences - deduplicate-toc - toc : permalink : \"#\" Why configure like this theme: material material is the only supported MkDocs theme . repo_url and icon Link back to your repository nicely. See more . extra_css Don't forget to copy and include the recommended styles . mkdocstrings: default_handler: crystal Activate the upstream mkdocstrings plugin and tell it to collect items from Crystal, not Python, by default. watch: [src] Watch a directory for auto-reload . Assuming the sources are under src/ . pymdownx.* extensions Python-Markdown is an \"old-school\" Markdown parser, and these extensions bring the defaults more in line with what people are used to now. deduplicate-toc extension This is actually an integral part of mkdocstrings-crystal . Read more . Add an API doc page # docs/api.md # module Foo The main class in our library is `Bar` . ::: Foo::Bar --- There is also a helper function: ::: Foo#g Add a normal page # docs/index.md # Introduction Welcome to my project! See [ the API documentation ]( api.md ). Make sure to check out [ Foo#g(bar) ][]. We linked directly to an identifier here, and mkdocstrings knows which page it's on and automatically links that. See: identifier linking syntax . View the site # That's it -- we're ready! mkdocs build # generate from docs/ into site/ mkdocs serve # live preview Next steps # If you find that you have too many classes and you don't want to manually create files with callouts to them, there are ways to automate it, and good examples are in the migration-oriented guide . Otherwise, you're encouraged to curate per-topic pages with your API items. See \"Manually curated docs page\" in Showcase for examples. And you'll probably want to set up a navigation config anyway.","title":"Quickstart"},{"location":"quickstart/index.html#quick-start-guide","text":"This assumes you already have some project in Crystal, say, a file src/foo.cr . src/foo.cr module Foo # Description of *Bar* class Bar # Description of *f* def f ( x : Int32 ) end end # Description of *g* # # See also: `Bar#f` def g ( bar : Bar ) end end Hosting on GitHub is also assumed, though that's easy to adapt. We'll be working from the project's root directory (the one that contains src ). View the final file layout","title":"Quick-start guide"},{"location":"quickstart/index.html#dependencies","text":"The dependencies that we'll be using can be installed like this: $ pip install mkdocs-material mkdocstrings-crystal This assumes you have Python installed, with pip available. Tip You might want to install these in a virtualenv (i.e. localized just to this project). And check out how to manage Python dependencies long-term.","title":"Dependencies"},{"location":"quickstart/index.html#base-config","text":"Let's configure MkDocs with mkdocstrings-crystal . Add/merge this config as your mkdocs.yml : mkdocs.yml site_name : My Project site_url : https://username.github.io/my-project/ repo_url : https://github.com/username/my-project edit_uri : blob/master/docs/ theme : name : material icon : repo : fontawesome/brands/github extra_css : - css/mkdocstrings.css plugins : - search - mkdocstrings : default_handler : crystal watch : [ src ] markdown_extensions : - pymdownx.highlight - pymdownx.magiclink - pymdownx.saneheaders - pymdownx.superfences - deduplicate-toc - toc : permalink : \"#\" Why configure like this theme: material material is the only supported MkDocs theme . repo_url and icon Link back to your repository nicely. See more . extra_css Don't forget to copy and include the recommended styles . mkdocstrings: default_handler: crystal Activate the upstream mkdocstrings plugin and tell it to collect items from Crystal, not Python, by default. watch: [src] Watch a directory for auto-reload . Assuming the sources are under src/ . pymdownx.* extensions Python-Markdown is an \"old-school\" Markdown parser, and these extensions bring the defaults more in line with what people are used to now. deduplicate-toc extension This is actually an integral part of mkdocstrings-crystal . Read more .","title":"Base config"},{"location":"quickstart/index.html#add-an-api-doc-page","text":"docs/api.md # module Foo The main class in our library is `Bar` . ::: Foo::Bar --- There is also a helper function: ::: Foo#g","title":"Add an API doc page"},{"location":"quickstart/index.html#add-a-normal-page","text":"docs/index.md # Introduction Welcome to my project! See [ the API documentation ]( api.md ). Make sure to check out [ Foo#g(bar) ][]. We linked directly to an identifier here, and mkdocstrings knows which page it's on and automatically links that. See: identifier linking syntax .","title":"Add a normal page"},{"location":"quickstart/index.html#view-the-site","text":"That's it -- we're ready! mkdocs build # generate from docs/ into site/ mkdocs serve # live preview","title":"View the site"},{"location":"quickstart/index.html#next-steps","text":"If you find that you have too many classes and you don't want to manually create files with callouts to them, there are ways to automate it, and good examples are in the migration-oriented guide . Otherwise, you're encouraged to curate per-topic pages with your API items. See \"Manually curated docs page\" in Showcase for examples. And you'll probably want to set up a navigation config anyway.","title":"Next steps"},{"location":"quickstart/ci.html","text":"Continuous build and publishing # You can build and publish the website automatically on push using GitHub Pages and GitHub Actions. Here's our recommendation: .github/workflows/deploy-docs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name : Deploy docs on : [ push , pull_request ] jobs : build : name : Deploy docs runs-on : ubuntu-latest steps : - name : Download source uses : actions/checkout@v2 - name : Install Crystal uses : oprypin/install-crystal@v1 - name : Install Python uses : actions/setup-python@v2 - name : Install Python libs run : pip install --no-deps -r requirements.txt - name : Install Crystal libs run : shards install - name : Build site run : mkdocs build - name : Deploy to gh-pages if : github.event_name == 'push' && github.ref == 'refs/heads/master' run : mkdocs gh-deploy --force Why configure like this Do not disable the workflow for non- master branches or pull requests. It is nice to ensure that the site builds (there can be errors!), instead at the bottom we prevent only the actual deploy action from being executed on non- master /non- pushes . Dependencies are installed from requirements.txt . Make sure you've populated it . Tip You can freely have a \"dev\" branch for working on docs that aren't ready for release yet. Then just merge it into the main one when ready. Tip Your docs don't have to be in the same repository as the main code. In fact, the doc site can span several projects! See \"Multi-repo setup\" in Showcase .","title":"Continuous build and publishing"},{"location":"quickstart/ci.html#continuous-build-and-publishing","text":"You can build and publish the website automatically on push using GitHub Pages and GitHub Actions. Here's our recommendation: .github/workflows/deploy-docs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name : Deploy docs on : [ push , pull_request ] jobs : build : name : Deploy docs runs-on : ubuntu-latest steps : - name : Download source uses : actions/checkout@v2 - name : Install Crystal uses : oprypin/install-crystal@v1 - name : Install Python uses : actions/setup-python@v2 - name : Install Python libs run : pip install --no-deps -r requirements.txt - name : Install Crystal libs run : shards install - name : Build site run : mkdocs build - name : Deploy to gh-pages if : github.event_name == 'push' && github.ref == 'refs/heads/master' run : mkdocs gh-deploy --force Why configure like this Do not disable the workflow for non- master branches or pull requests. It is nice to ensure that the site builds (there can be errors!), instead at the bottom we prevent only the actual deploy action from being executed on non- master /non- pushes . Dependencies are installed from requirements.txt . Make sure you've populated it . Tip You can freely have a \"dev\" branch for working on docs that aren't ready for release yet. Then just merge it into the main one when ready. Tip Your docs don't have to be in the same repository as the main code. In fact, the doc site can span several projects! See \"Multi-repo setup\" in Showcase .","title":"Continuous build and publishing"},{"location":"quickstart/migrate.html","text":"Migrating from Crystal's built-in doc generator # This assumes you already have some project in Crystal, say, a file src/foo.cr . src/foo.cr module Foo # Description of *Bar* class Bar # Description of *f* def f ( x : Int32 ) end end # Description of *g* # # See also: `Bar#f` def g ( bar : Bar ) end end Hosting on GitHub is also assumed, though that's easy to adapt. We'll be working from the project's root directory (the one that contains src ). View the final file layout Dependencies # The dependencies that we'll be using can be installed like this: $ pip install mkdocs-material mkdocstrings-crystal mkdocs-gen-files mkdocs-literate-nav mkdocs-section-index This assumes you have Python installed, with pip available. Tip You might want to install these in a virtualenv (i.e. localized just to this project). Otherwise, they go to ~/.local/lib/python* . And check out how to manage Python dependencies long-term. Base config # Let's configure MkDocs with mkdocstrings-crystal . Add/merge this config as your mkdocs.yml : mkdocs.yml site_name : My Project site_url : https://username.github.io/my-project/ repo_url : https://github.com/username/my-project edit_uri : blob/master/docs/ theme : name : material icon : repo : fontawesome/brands/github extra_css : - css/mkdocstrings.css plugins : - search - gen-files : scripts : - docs/gen_doc_stubs.py - mkdocstrings : default_handler : crystal watch : [ src ] - literate-nav : nav_file : SUMMARY.md - section-index markdown_extensions : - pymdownx.highlight - deduplicate-toc - toc : permalink : \"#\" Why configure like this gen-files plugin Crystal's API generator automatically creates one HTML file per Crystal class. mkdocstrings doesn't do anything like that by itself, instead giving you the ability to present a story and perhaps mention several items per page. However, in this guide we choose to do a 1:1 migration and don't want to manually create all those pages (e.g. a page Foo/Bar/index.md containing just ::: Foo::Bar , so on and so on). Continued literate-nav plugin Right now it's not doing anything, we'll get back to it. section-index plugin In Crystal's API doc sites we are used to having double functionality behind clicking an item in the left side navigation: it both opens a type's page and expands its sub-types. Well, in MkDocs world that's very much non-standard. But we bring that back with this plugin. deduplicate-toc extension This is actually an integral part of mkdocstrings-crystal . Read more . toc: permalink: \"#\" Add an \"#\" anchor link after every heading so it's easy to link back to it. Not required, but very common, and Crystal doc generator does it too. extra_css Don't forget to copy and include the recommended styles . Important The \"literate-nav\" plugin must appear before \"section-index\" in the list, because it overwrites the nav. Generate doc stub pages # Add a script that will automatically populate a page for each type that exists in your project, with appropriate navigation. We're not populating the actual content, just inserting a small placeholder into each file for mkdocstrings to pick up. docs/gen_doc_stubs.py # Generate virtual doc files for the mkdocs site. # You can also run this script directly to actually write out those files, as a preview. import mkdocs_gen_files # Get the documentation root object root = mkdocs_gen_files . config [ 'plugins' ][ 'mkdocstrings' ] . get_handler ( 'crystal' ) . collector . root # For each type (e.g. \"Foo::Bar\") for typ in root . walk_types (): # Use the file name \"Foo/Bar/index.md\" filename = '/' . join ( typ . abs_id . split ( '::' ) + [ 'index.md' ]) # Make a file with the content \"# ::: Foo::Bar\\n\" with mkdocs_gen_files . open ( filename , 'w' ) as f : print ( f '# ::: { typ . abs_id } ' , file = f ) # Link to the type itself when clicking the \"edit\" button on the page. if typ . locations : mkdocs_gen_files . set_edit_path ( filename , typ . locations [ 0 ] . url ) This script is picked up to run seamlessly as part of the normal site build, because we had configured the gen-files plugin , which is already explained above. Tip Find more advanced examples of such scripts in Showcase . Add a normal page # docs/index.md # Introduction Welcome to my project! Make sure to check out the [ API documentation ]( Foo/ ), particularly [ Foo#g(bar) ][]. We linked directly to an identifier here, and mkdocstrings knows which page it's on and automatically links that. See: identifier linking syntax . View the site # That's it -- we're ready! $ mkdocs build # generate from docs/ into site/ $ mkdocs serve # live preview Setting up navigation long-term # This is finally where the literate-nav plugin comes in. Eventually you'll want to define an order for your pages to appear in the navigation, but if you have so many generated API doc pages, that becomes infeasible. MkDocs doesn't have any way to infer only parts of the navigation, only all or nothing. So, let's start a nav file. docs/SUMMARY.md * [ Introduction ]( index.md ) * [ API ]( Foo/ ) First presumably you'd have a concrete list of pages, and as the last item, perhaps you'd leave the whole Foo/ sub-structure to be inferred. See \"Partly inferred nav\" examples in Showcase . Also check out the \"navigation tabs\" theme feature. Really preserving the URLs # (This is optional.) We've been generating URLs such as /Foo/Bar/ (or /Foo/Bar/index.html ). But to actually keep all the URLs exactly like crystal doc 's site (for a non-breaking migration), we choose to make them look like /Foo/Bar.html instead. Add this to the top of mkdocs.yml -- this is the actual change making it so: use_directory_urls : false But if you make this change by itself, MkDocs will no longer be able to group them into subsections nicely by default; it just doesn't see /Foo.md as the index page for the section containing /Foo/*.md , instead they'll be confusingly split into two. So the navigation now has to be specified fully explicitly. As we've been generating the stub files, let's also generate the nav file itself. The file docs/gen_doc_stubs.py will gain these additions: docs/gen_doc_stubs.py # Generate virtual doc files for the mkdocs site. # You can also run this script directly to actually write out those files, as a preview. import mkdocs_gen_files # Get the documentation root object root = mkdocs_gen_files . config [ 'plugins' ][ 'mkdocstrings' ] . get_handler ( 'crystal' ) . collector . root # Start a navigation file (to be filled as we go along) nav = mkdocs_gen_files . open ( 'SUMMARY.md' , 'a' ) # For each type (e.g. \"Foo::Bar\") for typ in root . walk_types (): # Use the file name \"Foo/Bar.md\" filename = '/' . join ( typ . abs_id . split ( '::' )) + '.md' # Make a file with the content \"# ::: Foo::Bar\\n\" with mkdocs_gen_files . open ( filename , 'w' ) as f : print ( f '# ::: { typ . abs_id } ' , file = f ) # Link to the type itself when clicking the \"edit\" button on the page if typ . locations : mkdocs_gen_files . set_edit_path ( filename , typ . locations [ 0 ] . url ) # Append to the nav: \" * [Bar](Foo/Bar.md)\" indent = ' ' * typ . abs_id . count ( '::' ) print ( indent + f '* [ { typ . name } ]( { filename } )' , file = nav )","title":"Migrate from `crystal doc`"},{"location":"quickstart/migrate.html#migrating-from-crystals-built-in-doc-generator","text":"This assumes you already have some project in Crystal, say, a file src/foo.cr . src/foo.cr module Foo # Description of *Bar* class Bar # Description of *f* def f ( x : Int32 ) end end # Description of *g* # # See also: `Bar#f` def g ( bar : Bar ) end end Hosting on GitHub is also assumed, though that's easy to adapt. We'll be working from the project's root directory (the one that contains src ). View the final file layout","title":"Migrating from Crystal's built-in doc generator"},{"location":"quickstart/migrate.html#dependencies","text":"The dependencies that we'll be using can be installed like this: $ pip install mkdocs-material mkdocstrings-crystal mkdocs-gen-files mkdocs-literate-nav mkdocs-section-index This assumes you have Python installed, with pip available. Tip You might want to install these in a virtualenv (i.e. localized just to this project). Otherwise, they go to ~/.local/lib/python* . And check out how to manage Python dependencies long-term.","title":"Dependencies"},{"location":"quickstart/migrate.html#base-config","text":"Let's configure MkDocs with mkdocstrings-crystal . Add/merge this config as your mkdocs.yml : mkdocs.yml site_name : My Project site_url : https://username.github.io/my-project/ repo_url : https://github.com/username/my-project edit_uri : blob/master/docs/ theme : name : material icon : repo : fontawesome/brands/github extra_css : - css/mkdocstrings.css plugins : - search - gen-files : scripts : - docs/gen_doc_stubs.py - mkdocstrings : default_handler : crystal watch : [ src ] - literate-nav : nav_file : SUMMARY.md - section-index markdown_extensions : - pymdownx.highlight - deduplicate-toc - toc : permalink : \"#\" Why configure like this gen-files plugin Crystal's API generator automatically creates one HTML file per Crystal class. mkdocstrings doesn't do anything like that by itself, instead giving you the ability to present a story and perhaps mention several items per page. However, in this guide we choose to do a 1:1 migration and don't want to manually create all those pages (e.g. a page Foo/Bar/index.md containing just ::: Foo::Bar , so on and so on). Continued literate-nav plugin Right now it's not doing anything, we'll get back to it. section-index plugin In Crystal's API doc sites we are used to having double functionality behind clicking an item in the left side navigation: it both opens a type's page and expands its sub-types. Well, in MkDocs world that's very much non-standard. But we bring that back with this plugin. deduplicate-toc extension This is actually an integral part of mkdocstrings-crystal . Read more . toc: permalink: \"#\" Add an \"#\" anchor link after every heading so it's easy to link back to it. Not required, but very common, and Crystal doc generator does it too. extra_css Don't forget to copy and include the recommended styles . Important The \"literate-nav\" plugin must appear before \"section-index\" in the list, because it overwrites the nav.","title":"Base config"},{"location":"quickstart/migrate.html#generate-doc-stub-pages","text":"Add a script that will automatically populate a page for each type that exists in your project, with appropriate navigation. We're not populating the actual content, just inserting a small placeholder into each file for mkdocstrings to pick up. docs/gen_doc_stubs.py # Generate virtual doc files for the mkdocs site. # You can also run this script directly to actually write out those files, as a preview. import mkdocs_gen_files # Get the documentation root object root = mkdocs_gen_files . config [ 'plugins' ][ 'mkdocstrings' ] . get_handler ( 'crystal' ) . collector . root # For each type (e.g. \"Foo::Bar\") for typ in root . walk_types (): # Use the file name \"Foo/Bar/index.md\" filename = '/' . join ( typ . abs_id . split ( '::' ) + [ 'index.md' ]) # Make a file with the content \"# ::: Foo::Bar\\n\" with mkdocs_gen_files . open ( filename , 'w' ) as f : print ( f '# ::: { typ . abs_id } ' , file = f ) # Link to the type itself when clicking the \"edit\" button on the page. if typ . locations : mkdocs_gen_files . set_edit_path ( filename , typ . locations [ 0 ] . url ) This script is picked up to run seamlessly as part of the normal site build, because we had configured the gen-files plugin , which is already explained above. Tip Find more advanced examples of such scripts in Showcase .","title":"Generate doc stub pages"},{"location":"quickstart/migrate.html#add-a-normal-page","text":"docs/index.md # Introduction Welcome to my project! Make sure to check out the [ API documentation ]( Foo/ ), particularly [ Foo#g(bar) ][]. We linked directly to an identifier here, and mkdocstrings knows which page it's on and automatically links that. See: identifier linking syntax .","title":"Add a normal page"},{"location":"quickstart/migrate.html#view-the-site","text":"That's it -- we're ready! $ mkdocs build # generate from docs/ into site/ $ mkdocs serve # live preview","title":"View the site"},{"location":"quickstart/migrate.html#setting-up-navigation-long-term","text":"This is finally where the literate-nav plugin comes in. Eventually you'll want to define an order for your pages to appear in the navigation, but if you have so many generated API doc pages, that becomes infeasible. MkDocs doesn't have any way to infer only parts of the navigation, only all or nothing. So, let's start a nav file. docs/SUMMARY.md * [ Introduction ]( index.md ) * [ API ]( Foo/ ) First presumably you'd have a concrete list of pages, and as the last item, perhaps you'd leave the whole Foo/ sub-structure to be inferred. See \"Partly inferred nav\" examples in Showcase . Also check out the \"navigation tabs\" theme feature.","title":"Setting up navigation long-term"},{"location":"quickstart/migrate.html#really-preserving-the-urls","text":"(This is optional.) We've been generating URLs such as /Foo/Bar/ (or /Foo/Bar/index.html ). But to actually keep all the URLs exactly like crystal doc 's site (for a non-breaking migration), we choose to make them look like /Foo/Bar.html instead. Add this to the top of mkdocs.yml -- this is the actual change making it so: use_directory_urls : false But if you make this change by itself, MkDocs will no longer be able to group them into subsections nicely by default; it just doesn't see /Foo.md as the index page for the section containing /Foo/*.md , instead they'll be confusingly split into two. So the navigation now has to be specified fully explicitly. As we've been generating the stub files, let's also generate the nav file itself. The file docs/gen_doc_stubs.py will gain these additions: docs/gen_doc_stubs.py # Generate virtual doc files for the mkdocs site. # You can also run this script directly to actually write out those files, as a preview. import mkdocs_gen_files # Get the documentation root object root = mkdocs_gen_files . config [ 'plugins' ][ 'mkdocstrings' ] . get_handler ( 'crystal' ) . collector . root # Start a navigation file (to be filled as we go along) nav = mkdocs_gen_files . open ( 'SUMMARY.md' , 'a' ) # For each type (e.g. \"Foo::Bar\") for typ in root . walk_types (): # Use the file name \"Foo/Bar.md\" filename = '/' . join ( typ . abs_id . split ( '::' )) + '.md' # Make a file with the content \"# ::: Foo::Bar\\n\" with mkdocs_gen_files . open ( filename , 'w' ) as f : print ( f '# ::: { typ . abs_id } ' , file = f ) # Link to the type itself when clicking the \"edit\" button on the page if typ . locations : mkdocs_gen_files . set_edit_path ( filename , typ . locations [ 0 ] . url ) # Append to the nav: \" * [Bar](Foo/Bar.md)\" indent = ' ' * typ . abs_id . count ( '::' ) print ( indent + f '* [ { typ . name } ]( { filename } )' , file = nav )","title":"Really preserving the URLs"},{"location":"quickstart/python-dependencies.html","text":"Managing Python dependencies # There are countless ways to do it, but this document is nice for people not familiar with Python. This assumes you have Python installed, with pip available. Note Of course, you can just always run a bare pip install (without versions), but dependencies can break from under you with upgrades. We suggest to lock all dependencies' versions (recursively), so the same ones are always used. As an example, let's use the typical list of dependencies mentioned throughout this site. Put these into the file requirements.in : mkdocs mkdocs-material mkdocstrings-crystal mkdocs-gen-files mkdocs-literate-nav mkdocs-section-index Install the pip-compile tool: $ pip install pip-tools Note This is needed only to manage the lock files; it won't be a permanent dependency. And run it: $ pip-compile -U requirements.in (also run this whenever you want to upgrade the dependencies). It creates the file requirements.txt , which is what you'll be using henceforth. Example requirements.txt # # This file is autogenerated by pip-compile # To update, run: # # pip-compile requirements.in # cached-property == 1.5.2 # via mkdocstrings-crystal click == 7.1.2 # via mkdocs, nltk future == 0.18.2 # via lunr glob2 == 0.7 # via mkdocs-literate-nav jinja2 == 2.11.3 # via mkdocs, mkdocstrings, mkdocstrings-crystal joblib == 1.0.1 # via nltk livereload == 2.6.3 # via mkdocs lunr [ languages ] == 0.5.8 # via mkdocs markdown == 3.3.4 # via mkdocs, mkdocs-autorefs, mkdocs-material, mkdocstrings, pymdown-extensions markupsafe == 1.1.1 # via jinja2, mkdocstrings, mkdocstrings-crystal mkdocs-autorefs == 0.1.1 # via mkdocstrings mkdocs-gen-files == 0.3.0 # via -r requirements.in mkdocs-literate-nav == 0.3.0 # via -r requirements.in mkdocs-material-extensions == 1.0.1 # via mkdocs-material mkdocs-material == 6.2.8 # via -r requirements.in, mkdocs-material-extensions, mkdocstrings-crystal mkdocs-section-index == 0.2.3 # via -r requirements.in mkdocs == 1.1.2 # via -r requirements.in, mkdocs-autorefs, mkdocs-gen-files, mkdocs-literate-nav, mkdocs-material, mkdocs-section-index, mkdocstrings mkdocstrings-crystal == 0.3.0 # via -r requirements.in mkdocstrings == 0.15.0 # via mkdocstrings-crystal nltk == 3.5 # via lunr pygments == 2.8.0 # via mkdocs-material pymdown-extensions == 8.1.1 # via mkdocs-material, mkdocstrings pytkdocs == 0.11.0 # via mkdocstrings pyyaml == 5.4.1 # via mkdocs regex == 2020.11.13 # via nltk six == 1.15.0 # via livereload, lunr tornado == 6.1 # via livereload, mkdocs tqdm == 4.58.0 # via nltk Now anyone ( including automation ) can install the exact same dependencies, and you can be sure the site will build as intended: $ pip install -r requirements.txt Tip If you'll be maintaining several projects with different dependencies, you might want to install packages in a virtualenv (effectively localized just to this project's folder). Important Both requirements.in and requirements.txt should be checked into source control. Depending on the layout of project, you have many options where to store those files: at the root directory (more pragmatic); as docs/requirements.txt (because, after all, this is docs' requirements, but you'll get a side effect that this file will become part of the built site); any other location you come up with -- just use pip install -r any_other_location/requirements.txt .","title":"Managing Python dependencies"},{"location":"quickstart/python-dependencies.html#managing-python-dependencies","text":"There are countless ways to do it, but this document is nice for people not familiar with Python. This assumes you have Python installed, with pip available. Note Of course, you can just always run a bare pip install (without versions), but dependencies can break from under you with upgrades. We suggest to lock all dependencies' versions (recursively), so the same ones are always used. As an example, let's use the typical list of dependencies mentioned throughout this site. Put these into the file requirements.in : mkdocs mkdocs-material mkdocstrings-crystal mkdocs-gen-files mkdocs-literate-nav mkdocs-section-index Install the pip-compile tool: $ pip install pip-tools Note This is needed only to manage the lock files; it won't be a permanent dependency. And run it: $ pip-compile -U requirements.in (also run this whenever you want to upgrade the dependencies). It creates the file requirements.txt , which is what you'll be using henceforth. Example requirements.txt # # This file is autogenerated by pip-compile # To update, run: # # pip-compile requirements.in # cached-property == 1.5.2 # via mkdocstrings-crystal click == 7.1.2 # via mkdocs, nltk future == 0.18.2 # via lunr glob2 == 0.7 # via mkdocs-literate-nav jinja2 == 2.11.3 # via mkdocs, mkdocstrings, mkdocstrings-crystal joblib == 1.0.1 # via nltk livereload == 2.6.3 # via mkdocs lunr [ languages ] == 0.5.8 # via mkdocs markdown == 3.3.4 # via mkdocs, mkdocs-autorefs, mkdocs-material, mkdocstrings, pymdown-extensions markupsafe == 1.1.1 # via jinja2, mkdocstrings, mkdocstrings-crystal mkdocs-autorefs == 0.1.1 # via mkdocstrings mkdocs-gen-files == 0.3.0 # via -r requirements.in mkdocs-literate-nav == 0.3.0 # via -r requirements.in mkdocs-material-extensions == 1.0.1 # via mkdocs-material mkdocs-material == 6.2.8 # via -r requirements.in, mkdocs-material-extensions, mkdocstrings-crystal mkdocs-section-index == 0.2.3 # via -r requirements.in mkdocs == 1.1.2 # via -r requirements.in, mkdocs-autorefs, mkdocs-gen-files, mkdocs-literate-nav, mkdocs-material, mkdocs-section-index, mkdocstrings mkdocstrings-crystal == 0.3.0 # via -r requirements.in mkdocstrings == 0.15.0 # via mkdocstrings-crystal nltk == 3.5 # via lunr pygments == 2.8.0 # via mkdocs-material pymdown-extensions == 8.1.1 # via mkdocs-material, mkdocstrings pytkdocs == 0.11.0 # via mkdocstrings pyyaml == 5.4.1 # via mkdocs regex == 2020.11.13 # via nltk six == 1.15.0 # via livereload, lunr tornado == 6.1 # via livereload, mkdocs tqdm == 4.58.0 # via nltk Now anyone ( including automation ) can install the exact same dependencies, and you can be sure the site will build as intended: $ pip install -r requirements.txt Tip If you'll be maintaining several projects with different dependencies, you might want to install packages in a virtualenv (effectively localized just to this project's folder). Important Both requirements.in and requirements.txt should be checked into source control. Depending on the layout of project, you have many options where to store those files: at the root directory (more pragmatic); as docs/requirements.txt (because, after all, this is docs' requirements, but you'll get a side effect that this file will become part of the built site); any other location you come up with -- just use pip install -r any_other_location/requirements.txt .","title":"Managing Python dependencies"}]}